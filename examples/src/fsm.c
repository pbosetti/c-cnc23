/******************************************************************************
Finite State Machine
Project: VM
Description: Finite state machine for vending machine

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2023-05-04 16:00:44 +0200
Generated from: fsm_vending.dot
The finite state machine has:
  7 states
  3 transition functions
Functions and types have been generated with prefix "vm_"
******************************************************************************/

#include <syslog.h>
#include <stdio.h>
#include <termios.h>
#include <unistd.h>
#include "fsm.h"

static char read_key() {
  char key;
  struct termios old_tio, new_tio;
  // save current terminal settings
  tcgetattr(STDIN_FILENO, &old_tio);
  // copy setting into new structure
  new_tio = old_tio;
  // disable caching 
  cfmakeraw(&new_tio);
  // set new settings
  tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);
  // wait for keypress
  key = getchar();
  // reset initial temrinal setings
  tcsetattr(STDIN_FILENO, TCSANOW, &old_tio);
  return key;
}


// Install signal handler: 
// SIGINT requests a transition to state stop
#include <signal.h>
static int _exit_request = 0;
static void signal_handler(int signal) {
  if (signal == SIGINT) {
    _exit_request = 1;
    syslog(LOG_WARNING, "[FSM] SIGINT transition to stop");
  }
}

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

// GLOBALS
// State human-readable names
const char *vm_state_names[] = {"init", "idle", "coin_in", "stop", "return_coin", "selection", "dispensing"};

// List of state functions
state_func_t *const vm_state_table[VM_NUM_STATES] = {
  vm_do_init,        // in state init
  vm_do_idle,        // in state idle
  vm_do_coin_in,     // in state coin_in
  vm_do_stop,        // in state stop
  vm_do_return_coin, // in state return_coin
  vm_do_selection,   // in state selection
  vm_do_dispensing,  // in state dispensing
};

// Table of transition functions
transition_func_t *const vm_transition_table[VM_NUM_STATES][VM_NUM_STATES] = {
  /* states:         init           , idle           , coin_in        , stop           , return_coin    , selection      , dispensing      */
  /* init        */ {NULL           , NULL           , NULL           , NULL           , NULL           , NULL           , NULL           }, 
  /* idle        */ {NULL           , NULL           , NULL           , NULL           , NULL           , NULL           , NULL           }, 
  /* coin_in     */ {NULL           , NULL           , NULL           , NULL           , NULL           , NULL           , NULL           }, 
  /* stop        */ {NULL           , NULL           , NULL           , NULL           , NULL           , NULL           , NULL           }, 
  /* return_coin */ {NULL           , NULL           , NULL           , NULL           , NULL           , NULL           , NULL           }, 
  /* selection   */ {NULL           , NULL           , NULL           , NULL           , NULL           , NULL           , NULL           }, 
  /* dispensing  */ {NULL           , vm_reset       , NULL           , NULL           , vm_disable_line, NULL           , NULL           }, 
};

/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: VM_STATE_IDLE
vm_state_t vm_do_init(vm_state_data_t *data) {
  vm_state_t next_state = VM_STATE_IDLE;
  signal(SIGINT, signal_handler); 
  
  syslog(LOG_INFO, "[FSM] In state init");
  data->counts[0] = 3;  
  data->counts[1] = 10;  
  data->counts[2] = 5;  
  data->counts[3] = 10;  
  data->coins = 0;
  
  switch (next_state) {
    case VM_STATE_IDLE:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from init to %s, remaining in this state", vm_state_names[next_state]);
      next_state = VM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state idle
// valid return states: VM_NO_CHANGE, VM_STATE_IDLE, VM_STATE_COIN_IN, VM_STATE_STOP
// SIGINT triggers an emergency transition to stop
vm_state_t vm_do_idle(vm_state_data_t *data) {
  vm_state_t next_state = VM_NO_CHANGE;
  char key;
  
  syslog(LOG_INFO, "[FSM] In state idle");
  printf("Insert coins [1-9]\n");
  key = read_key();
  if (key >= '0' && key <= '9') {
    data->coins = key - '0';
    next_state = VM_STATE_COIN_IN;
  } else if (key == 's') {
    _exit_request = 1;
  } else {
    printf("Invalid key '%c'\n", key);
  }
  
  switch (next_state) {
    case VM_NO_CHANGE:
    case VM_STATE_IDLE:
    case VM_STATE_COIN_IN:
    case VM_STATE_STOP:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from idle to %s, remaining in this state", vm_state_names[next_state]);
      next_state = VM_NO_CHANGE;
  }
  
  // SIGINT transition override
  if (_exit_request) next_state = VM_STATE_STOP;
  
  return next_state;
}


// Function to be executed in state coin_in
// valid return states: VM_NO_CHANGE, VM_STATE_COIN_IN, VM_STATE_RETURN_COIN, VM_STATE_SELECTION
// SIGINT triggers an emergency transition to stop
vm_state_t vm_do_coin_in(vm_state_data_t *data) {
  vm_state_t next_state = VM_NO_CHANGE;
  char key;

  syslog(LOG_INFO, "[FSM] In state coin_in");
  printf("Current sale: %d. Press spacebar to select item, 'x' to cancel\n", data->coins);
  key = read_key();
  if (key >= '0' && key <= '9') {
    data->coins += key - '0';
  }
  else if (key == ' ') {
    next_state = VM_STATE_SELECTION;
  }
  else if (key == 'x') {
    next_state = VM_STATE_RETURN_COIN;
  }
  else if (key == 's') {
    _exit_request = 1;
  }
  
  switch (next_state) {
    case VM_NO_CHANGE:
    case VM_STATE_COIN_IN:
    case VM_STATE_RETURN_COIN:
    case VM_STATE_SELECTION:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from coin_in to %s, remaining in this state", vm_state_names[next_state]);
      next_state = VM_NO_CHANGE;
  }
  
  // SIGINT transition override
  if (_exit_request) next_state = VM_STATE_STOP;
  
  return next_state;
}


// Function to be executed in state stop
// valid return states: VM_NO_CHANGE
vm_state_t vm_do_stop(vm_state_data_t *data) {
  vm_state_t next_state = VM_NO_CHANGE;
  
  syslog(LOG_INFO, "[FSM] In state stop");
  printf("Total cash: %d\n", data->total_cash);
  
  switch (next_state) {
    case VM_NO_CHANGE:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from stop to %s, remaining in this state", vm_state_names[next_state]);
      next_state = VM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state return_coin
// valid return states: VM_STATE_IDLE
vm_state_t vm_do_return_coin(vm_state_data_t *data) {
  vm_state_t next_state = VM_STATE_IDLE;
  
  syslog(LOG_INFO, "[FSM] In state return_coin");
  printf("Returning %d coins\n", data->coins);
  data->coins = 0;
  
  switch (next_state) {
    case VM_STATE_IDLE:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from return_coin to %s, remaining in this state", vm_state_names[next_state]);
      next_state = VM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state selection
// valid return states: VM_NO_CHANGE, VM_STATE_SELECTION, VM_STATE_DISPENSING
// SIGINT triggers an emergency transition to stop
vm_state_t vm_do_selection(vm_state_data_t *data) {
  vm_state_t next_state = VM_NO_CHANGE;
  char key;

  syslog(LOG_INFO, "[FSM] In state selection");
  printf("Availability: [%d] [%d] [%d] [%d]\n", data->counts[0], data->counts[1], data->counts[2], data->counts[3]);
  printf("Select line [1-4]\n");
  key = read_key();
  if (key >= '1' && key <= '4') {
    data->selection = key - '1';
    next_state = VM_STATE_DISPENSING;
  }
  else {
    printf("Invalid selection\n");
  }

  
  switch (next_state) {
    case VM_NO_CHANGE:
    case VM_STATE_SELECTION:
    case VM_STATE_DISPENSING:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from selection to %s, remaining in this state", vm_state_names[next_state]);
      next_state = VM_NO_CHANGE;
  }
  
  // SIGINT transition override
  if (_exit_request) next_state = VM_STATE_STOP;
  
  return next_state;
}


// Function to be executed in state dispensing
// valid return states: VM_NO_CHANGE, VM_STATE_IDLE, VM_STATE_RETURN_COIN, VM_STATE_DISPENSING
// SIGINT triggers an emergency transition to stop
vm_state_t vm_do_dispensing(vm_state_data_t *data) {
  vm_state_t next_state = VM_NO_CHANGE;
  static int steps = 5;

  syslog(LOG_INFO, "[FSM] In state dispensing");
  if (steps-- > 0) {
    printf(".");
    fflush(stdout);
  } else {
    steps = 5;
    printf("Dispensing 1 item from line %d\n", data->selection + 1);
    data->counts[data->selection]--;
    if (data->counts[data->selection] < 0) {
      printf("Error dispensing from this line\n");
      data->failed_line = data->selection;
      next_state = VM_STATE_RETURN_COIN;
    }
    else {
      next_state = VM_STATE_IDLE;
    }
  }

  switch (next_state) {
    case VM_NO_CHANGE:
    case VM_STATE_IDLE:
    case VM_STATE_RETURN_COIN:
    case VM_STATE_DISPENSING:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from dispensing to %s, remaining in this state", vm_state_names[next_state]);
      next_state = VM_NO_CHANGE;
  }
  
  // SIGINT transition override
  if (_exit_request) next_state = VM_STATE_STOP;
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */    
                                         

// This function is called in 1 transition:
// 1. from dispensing to idle
void vm_reset(vm_state_data_t *data) {
  syslog(LOG_INFO, "[FSM] State transition vm_reset");
  data->total_cash += data->coins;
  data->coins = 0;
}

// This function is called in 1 transition:
// 1. from dispensing to return_coin
void vm_disable_line(vm_state_data_t *data) {
  syslog(LOG_INFO, "[FSM] State transition vm_disable_line");
  printf("Disabling line %d\n", data->failed_line);
}


/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

vm_state_t vm_run_state(vm_state_t cur_state, vm_state_data_t *data) {
  vm_state_t new_state = vm_state_table[cur_state](data);
  if (new_state == VM_NO_CHANGE) new_state = cur_state;
  transition_func_t *transition = vm_transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  vm_state_t cur_state = VM_STATE_INIT;
  openlog("SM", LOG_PID | LOG_PERROR, LOG_USER);
  syslog(LOG_INFO, "Starting SM");
  do {
    cur_state = vm_run_state(cur_state, NULL);
    sleep(1);
  } while (cur_state != VM_STATE_STOP);
  vm_run_state(cur_state, NULL);
  return 0;
}
#endif
